## 1）什么是线程 Thread

在内存和CPU之间，建立一条连接通路，CPU可以到内存中取出数据进行计算，这个连接的通路，就是线程。

进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

> 一个独立的进程，可以开启多个线程（多条通路）。即多线程。CPU取的数据都是线程中的数据，所以CPU运行的不是进程，而是线程。
>
> 对于java程序来说，当在terminal或DOS命令窗口中输入：java HelloWorld 回车之后，会先启动JVM，而JVM就是一个进程。JVM在启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收线程，一个是执行main方法的主线程。 



## 2）什么是进程 Process

>  任何的存储在磁盘中的软件在运行的时候，OS使用IO技术，将磁盘中软件的文件加载到内存，程序才能运行。

应用软件运行的时候进入到内存，程序在内存中占用占用的内存空间。

通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。



## 3）什么是并发

同一个时刻多个线程同时操作了同一个数据。多个线程可以同时执行，且不会互相干扰。

> 很多人同时抢一张票，称为高并发。



## 4）什么是并行

同一个时刻多个线程同时执行不同的程序。

> 电脑同时打开IDEA，Typora等软件。



## 5）线程的状态

Thread.State

```java
public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW, // 新建

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE, // 准备就绪

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED, // 阻塞

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called <tt>Object.wait()</tt>
     * on an object is waiting for another thread to call
     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
     * that object. A thread that has called <tt>Thread.join()</tt>
     * is waiting for a specified thread to terminate.
     */
    WAITING, // 不见不散

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING, // 过时不候

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED; // 终结
}
```

## 5.5）线程方法

```java
public class ThreadTest {
    public static void main(String[] args) {
        System.out.println(Thread.activeCount()); // 得到正在运行的线程的数量 这里是2:gc和main
        System.out.println(Runtime.getRuntime().availableProcessors()); // 得到cpu可运行的总线程数
    }
}
```

### join()

```java
public class Main {
    public static void main(String[] args) {
        ThreadTest.show();
    }
}

public class ThreadTest {
    public static void show() {
        
        Thread thread = new Thread(new DownloadFileTask());
        thread.start();
    
        try {
            thread.join(); // 等待其他线程执行完毕，此线程加入
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("File is ready to be scanned.");
    }
}

public class DownloadFileTask implements Runnable{
    @Override
    public void run() {
        System.out.println("Downloading a file: " + Thread.currentThread().getName());
    
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        System.out.println("Download complete: " + Thread.currentThread().getName());
    }
    
}
```

### interrupt()

```java
public class Main {
    public static void main(String[] args) {
        ThreadTest.show();
    }
}

public class ThreadTest {
    public static void show() {
        
        Thread thread = new Thread(new DownloadFileTask());
        thread.start();
    
        try {
            Thread.sleep(1000); // 模拟业务代码
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        thread.interrupt(); // 给线程发送一个打断信号，并不是强制打断线程
    }
}

public class DownloadFileTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Downloading a file: " + Thread.currentThread().getName());
        
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            if (Thread.currentThread().isInterrupted()) return;
            System.out.println("Downloading byte " + i);
        }
        
        System.out.println("Download complete: " + Thread.currentThread().getName());
    }
    
}
```







## 6）线程的优先级

int ---> getPriority() 获取线程的优先级

void ---> setPriority(int newPriority) 设置线程的优先级

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest10 {
    public static void main(String[] args) {
        //设置主线程的优先级为1
        Thread.currentThread().setPriority(1);
/*
        System.out.println("线程最低优先级："+ Thread.MIN_PRIORITY); //1
        System.out.println("线程最高优先级："+ Thread.MAX_PRIORITY); //10
        System.out.println("线程默认优先级："+ Thread.NORM_PRIORITY); //5
*/

//        System.out.println(Thread.currentThread().getName() + "线程的默认优先级：" + Thread.currentThread().getPriority());
        //main线程的默认优先级：5

        Thread t = new Thread(new MyRunnable5());
        t.setPriority(10);
        t.setName("t");
        t.start();

        //优先级较高的，抢到的CPU时间片相对多一些，即处于运行状态的时间多一些
        //大概率会偏向优先级较高的线程
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}

class MyRunnable5 implements Runnable {
    @Override
    public void run() {
        //System.out.println(Thread.currentThread().getName() + "线程的默认优先级：" + Thread.currentThread().getPriority());
        //t线程的默认优先级：5

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```


### 关于优先级：

static int MAX_PRIORITY 最高优先级是10

static int MIN_PRIORITY  最低优先级1

static int NORM_PRIORITY  默认优先级是5





## 7）创建线程

共四种：传统的是继承thread类和实现runnable接口，java5以后又有实现callable接口和java的线程池获得。

### 1. 继承 java.lang.Thread，重写 run 方法。

不建议使用，Java 是单继承，资源宝贵，要用接口方式。

```java
package com.raywei.moreaboutjava.thread;

/*
思考：为什么控制台输出结果有这样的特点：
    有先有后，有多有少。
    控制台只有一个？某个线程抢到执行权？
 */
public class ThreadTest01 {
    public static void main(String[] args) {
        //这里是main方法，这里的代码属于主线程，在主栈中运行

        //新建一个分支线程对象
        MyThread myThread = new MyThread();
        //启动线程
        /*
        start方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，
        这段代码任务完成之后，瞬间就结束了。它的任务只是为了开辟新的栈空间，
        空间开完，start方法就结束，分支线程启动成功。
        启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。
        run方法在分支栈的栈底部，main方法在主栈的栈底部，run和main是平级的。

        如果只用myThread.run(); run方法不会启动线程，不会分配新的分支线，这种方法就是单线程。
         */
        myThread.start();
        //这里的代码在主线程中运行
        for (int i = 0; i < 100; i++) {
            System.out.println("主线程--->" + i);
        }
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        //编写程序，这段程序运行在分支线程中（分支栈）。
        for (int i = 0; i < 100; i++) {
            System.out.println("分支线程--->" + i);
        }
    }
}
```



### 2. 实现 java.lang.Runnable 接口，实现run方法。

相比于第一种方法，此方法比较常用，因为类实现了接口，还可以去继承其他的类，更灵活。

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest02 {
    public static void main(String[] args) {
/*        MyRunnable myRunnable = new MyRunnable();

        *//*
        Thread Constructor：Thread(Runnable target)
         *//*

        Thread t = new Thread(myRunnable);*/
        
        //合并以上
        Thread t = new Thread(new MyRunnable());
        //start thread
        t.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("Main thread--->" + i);
        }
    }
}

//这不是一个线程类，是一个可运行的类。它还不是一个线程
class MyRunnable implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("multithreading-->" + i);
        }
    }
}
```

匿名内部类

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest03 {
    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("multithreading--------" + i);
                }
            }
        });

        t.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("main =======" + i);
        }
    }
}
```

匿名内部类使用lambda表达式

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest03 {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
          for (int i = 0; i < 100; i++) {
            System.out.println("multithreading--------" + i);
          }
        });

        t.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("main =======" + i);
        }
    }
}
```



### 3. 实现Callable接口（JDK8新特性）



Pros: 这种方式可以获取线程的返回值。前两种run方法返回值是void。

Cons: 效率比较低，在获取t线程的执行结果时，当前线程受阻塞，效率较低。

```java
package com.raywei.moreaboutjava.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask; // JUC 包下的，数据Java的并发包，JDK8新特性。

public class ThreadTest14 {
    public static void main(String[] args) {
        //第一步：创建一个"未来任务类"对象
        FutureTask task = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception { // call方法相当于run方法，只不过这个有返回值
                //线程执行一个任务，执行之后可能会有一个执行结果
                //模拟执行
                System.out.println("call method begins");
                Thread.sleep(1000 * 10);
                System.out.println("Call method ends");
                int a = 100;
                int b = 200;
                return a + b; //自动装箱，结果自动编程Integer
            }
        });

        //创建线程对象
        Thread t = new Thread(task);
        t.setName("t");
        t.start();
        //在主线程中，如何获取t线程的返回结果？
        try {
            Object o = task.get();
            System.out.println("result of thread: " + o);
            /*
            get方法会导致 当前线程阻塞
            main方法这里的程序要想执行必须等待get方法的结束
            而get方法可能需要很久，因为get方法是为了拿到另一个线程的执行结果
            另一个线程执行是需要时间的
             */
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println("hello world");
    }
}
```



### 4. 线程池



## 8）线程池

例子：10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。

线程池简单定义：处理过程中将任务放入队列，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。



### 线程池的优势

线程池的工作是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务。如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。它的主要特点为：线程复用；控制最大并发数;管理线程。

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。

第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。

第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。



### 线程池分类

Java中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。

static ExecutorService ---> newFixedThreadPool(int nThreads)

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

static ExecutorService ---> newSingleThreadExecutor()

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

static ExecutorService ---> newCachedThreadPool()

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

实际使用线程时以上都不会用，会自定义线程池。



### ThreadPoolExecutor

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

// 点进this
public ThreadPoolExecutor(int corePoolSize, // 线程池中的常驻核心线程数
                          int maximumPoolSize, // 线程池中能够容纳同时执行的最大线程数，此值必须大于等于1
                          long keepAliveTime, // 空闲线程的存活时间。当前池中线程数量超过corePoolSize、且当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止
                          TimeUnit unit, // 空闲线程存活时间单位 
                          BlockingQueue<Runnable> workQueue, // 任务队列，被提交但尚未被执行的任务
                          ThreadFactory threadFactory, // 表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可
                          RejectedExecutionHandler handler) { // 拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
    	  throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
   	   throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
          null :
          AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

![image-20220417205823881](https://s2.loli.net/2022/06/09/oUtuYQJd2BCTzPq.png)

```java
package com.raywei.juc;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author Ray Wei
 * @Date 2022/4/17 14:25
 */
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        // 自定义线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2, 5, 3L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(3)
        );

        // 模拟银行处理业务，10个顾客来办理业务
        try {
            for (int i = 1; i < 11; i++) {
                threadPoolExecutor.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"\t 处理业务");
                });
            }
        } finally {
            threadPoolExecutor.shutdown();
        }
    }
}
```

当任务<核心线程数(2)：1 调用核心线程池的线程 

当任务>核心线程数(2)：2 进入阻塞队列 

当任务>核心线程数(2)+阻塞队列个数(3)：3 最大线程池会开启一个线程执行任务 

当任务>核心线程数(2)+阻塞队列个数(3)+最大线程池个数(5-2=3)：4 拒绝策略

![image-20220417205835265](https://s2.loli.net/2022/06/09/6O53XyadMLbRhQE.png)

1、在创建了线程池后，线程池中的线程数为零。

2、当调用**execute()**方法添加一个请求任务时，线程池会做出如下判断：

 2.1如果正在运行的线程数量小于**corePoolSize**，那么马上创建线程运行这个任务；

 2.2如果正在运行的线程数量大于或等于**corePoolSize**，那么将这个任务放入队列；

 2.3如果这个时候队列满了且正在运行的线程数量还小于**maximumPoolSize**，那么还是要创建非核心线程立刻运行这个任务；

 2.4 如果队列满了且正在运行的线程数量大于或等于**maximumPoolSize**，那么线程池会启动饱和拒绝策略来执行。

3、当一个线程完成任务时，它会从队列中取下一个任务来执行。

4、当一个线程无事可做超过一定的时间（**keepAliveTime**）时，线程会判断：

  如果当前运行的线程数大于**corePoolSize**，那么这个线程就被停掉。

  所以线程池的所有任务完成后，它最终会收缩到**corePoolSize**的大小。



### 拒绝策略

```java
package com.raywei.juc;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author Ray Wei
 * @Date 2022/4/17 14:25
 */
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        // 自定义线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,
                5,
                3L,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(3),
                // 一般只使用前五个参数，后面的直接使用默认即可，不可能抛弃线程任务直接丢弃
                Executors.defaultThreadFactory(), // 使用默认的线程池工程
                new ThreadPoolExecutor.AbortPolicy() // 默认值，直接抛出异常，阻止运行 java.util.concurrent.RejectedExecutionException
                //new ThreadPoolExecutor.DiscardOldestPolicy() // 抛弃等待最久的任务，尝试加入新的任务
                //new ThreadPoolExecutor.CallerRunsPolicy() // 调用者执行任务
                //new ThreadPoolExecutor.DiscardPolicy() // 直接丢弃任务
                );

        // 模拟银行处理业务，10个顾客来办理业务
        try {
            for (int i = 1; i < 11; i++) {
                threadPoolExecutor.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 处理业务");
                });
            }
        } finally {
            threadPoolExecutor.shutdown();
        }
    }
}
```



## 9）什么是线程安全

以后在开发中，我们的项目都是运行在服务器中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码不需要编写。最重要的是，我们编写的代码需要放在一个多线程的环境下运行，更需要关注的是**这些数据在多线程并发的环境下是否是安全的**。



什么时候数据在多线程并发的环境下会存在安全问题呢？

需要满足三个条件：

1. 多线程并发
2. 有共享数据
3. 共享数据有修改的行为



解决线程安全问题

线程排队执行（不能并发），用排队执行解决线程安全问题，这种机制被称为：线程同步机制（专业术语）。

缺点：会牺牲一部分效率。但是只有数据安全的时候，才能谈效率的事。



## 10）多级缓存和一致性问题



## 11）CPU 时间片和原子性问题



## 12）指令重排和有序性问题



## 13）线程安全和内存模型



## 14）happens-before



## 15）可重入锁

可重入锁也叫递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。

在java环境下，ReentrantLock和synchronized都是可重入锁。



## 16）阻塞锁



## 17）乐观锁

> **乐观锁和悲观锁是两种思想，它们的使用是非常广泛的，不局限于某种编程语言或数据库。**

乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

乐观锁的实现方式主要有两种：CAS机制和版本号机制。

适用范围：读的多，冲突几率小。




## 18）悲观锁

悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的读锁、写锁、行锁、排它锁）。

适用范围：写的多，冲突几率大。



## 19）分布式锁



## 20）CAS

> Compare And Swap，又被称为自旋锁（一直在那转圈）。

### CAS 底层原理

三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。

### 案例

假设同时有线程A和线程B，他们都需要执行 i++。

Thread A：读取i，执行 i++，判断变量i的值是否发生改变。

1：没有改变，直接赋值

2:Thread B 非常快，已经执行完i++。Thread A判断出变量i的值已经改变，那么Thread A需要再次执行前面已经执行过的程序（即读取i，执行i++，判断变量i的值是否发生改变），直至成功完成给i的赋值。

<img src="https://s2.loli.net/2022/06/09/NhGAalBKYjSWQg4.jpg" style="zoom: 40%;" />

### 缺点：

#### 循环时间长开销大

自旋`CAS`（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。

如果`JVM`能支持处理器提供的`pause`指令那么效率会有一定的提升，`pause`指令有两个作用，第一它可以延迟流水线执行指令（`de-pipeline`）,使`CPU`不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（`memory order violation`）而引起CPU流水线被清空（`CPU pipeline flush`），从而提高`CPU`的执行效率。

> JDK限制：当竞争的线程数量>=10，或者单个线程自旋超过10次的时候，JDK强制将CAS锁取消，升级为重量级锁（通知OS锁定CPU和内存的通信总线）

#### 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。

还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。

从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

#### ABA问题

如下。



## 21）ABA

承上。

#### 由CAS锁产生的ABA问题

假设有三个线程，Thread A和B执行i++，Thread C执行i--。

B先执行i++，则i=1；C抢在A前面执行了i--，i=0。那么此时Thread A根据i的数值判断，以为i没有变过，其实已经变了两次了。

#### 如何解决ABA问题？

给变量i加上版本号。版本号只能增，不能减。

B先执行i++，则i=1，version=1.1；C抢在A前面执行了i--，i=0，version=1.2。那么此时Thread A根据i的数值判断没变，但是根据version的值判断，已经变化了，则再次执行前面已经执行过的程序。



## 22）偏向锁



## 23）轻量级锁



## 24）重量级锁



## 25）自旋锁



## 26）死锁 Dead Lock

### synchronized()导致的死锁

```java
package com.raywei.moreaboutjava.deadlock;
/*
死锁代码需要会写，面试官可能会要求写出来。
只有会写，以后在开发中才知道要注意这个事情。
因为死锁不会异常也不会报错，程序会一直僵持在那里，很难调试。
 */
public class DeadLockTest01 {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();

        MyThread1 t1 = new MyThread1(o1, o2);
        MyThread2 t2 = new MyThread2(o1, o2);

        t1.setName("t1");
        t2.setName("t2");

        t1.start();
        t2.start();
    }
}

class MyThread1 extends Thread {
    Object o1;
    Object o2;

    public MyThread1(Object o1, Object o2) {
        this.o1 = o1;
        this.o2 = o2;
    }
    @Override
    public void run() {
        //synchronized 最好不要嵌套使用
        synchronized (o1) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2) {

            }
        }
    }
}

class MyThread2 extends Thread {
    Object o1;
    Object o2;

    public MyThread2(Object o1, Object o2) {
        this.o1 = o1;
        this.o2 = o2;
    }
    @Override
    public void run() {
        synchronized (o2) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1) {

            }
        }
    }
}
```



### Lock导致的死锁

> https://jishuin.proginn.com/p/763bfbd5b219

```java
/**
 * @author wall
 * @date 2019/7/29  16:42
 * @description 实现一个死锁:A线程获取B线程占有的锁，B线程获取A线程占有的锁
 */
public class DeadLock {
    //定义两把锁
    private static ReentrantLock lockA = new ReentrantLock();
    private static ReentrantLock lockB = new ReentrantLock();
    //测试
    public static void main(String[] args) {
        //启动线程A,B
        new Thread(new A()).start();
        new Thread(new B()).start();
    }
 
    static class A implements Runnable{
        @Override
        public void run() {
            Thread.currentThread().setName("A线程");
            //获取锁A
            lockA.lock();
            System.out.println(Thread.currentThread().getName()+"获取锁A");
            //模拟业务操作
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //再获取锁B
            lockB.lock();
            System.out.println(Thread.currentThread().getName()+"获取锁B");
            lockA.unlock();
            lockB.unlock();
        }
    }
 
    static class B implements Runnable{
        @Override
        public void run() {
            Thread.currentThread().setName("B线程");
            //获取锁B
            lockB.lock();
            System.out.println(Thread.currentThread().getName()+"获取锁B");
            //模拟业务操作
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //再获取锁A
            lockA.lock();
            System.out.println(Thread.currentThread().getName()+"获取锁A");
        }
    }
}
```



## 27）如何避免死锁

是一开始就选择synchronized吗？不是，线程同步会让程序的执行效率降低，用户体验不好。系统的用户吞吐量/并发量降低。用户体验差。在不得已的情况下再选择线程同步机制。

第一种方案：尽量使用局部变量代替实例变量和静态变量。

第二种方案：如果必须使用实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不会共享了。

第三种方案：如果不能使用局部变量，也不能创建多个对象，那么就只能选择synchronized，线程同步机制。



## 28）synchronized

> 重量级锁，需要找OS锁。

### 关于synchronized小括号中的共享对象

Java中有三大变量：

实例变量：在堆中

静态变量：方法区中

局部变量：栈中

所以三大变量中，局部变量（+常量）是不会出现线程安全问题的。一个线程一个栈，局部变量在栈中，所以局部变量不会共享。

```java
package com.raywei.moreaboutjava.thread.threadsafe;

public class Account {
    private String actno;

    private double balance;

    //思考1，下面的对象能作为共享对象放在synchronized()的括号里吗？
    Object obj = new Object();
    /*
    Account只有一份，那么Account里面的obj也是只有一份，可以作为共享变量。
    实例变量，只有一个、可访问。
     */

    public String getActno() {
        return actno;
    }

    public void setActno(String actno) {
        this.actno = actno;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public Account(String actno, double balance) {
        this.actno = actno;
        this.balance = balance;
    }

    public Account() {
    }

    // 取款的方法
    public void withdraw(double money) {
        //以下这几行代码必须是线程排队的，不能并发
        //一个线程把这里的代码全部执行结束之后，另一个线程才能进来

        /*线程同步机制：
        小括号中传的这个数据是相当关键的，这个数据【必须是多线程共享的数据】。才能达到多线程排队。

        小括号中写什么？ 要看需要让哪些线程同步。假设有t1, t2, t3, t4, t5，5个线程，
        但是只需要t1, t2, t3排队，t4, t5不需要排队，怎么写？
        需要在()中写一个t1, t2, t3共享的对象，而这个对象对t4, t5来说不是共享的。

        这里的共享对象是 账户对象，而this就是账户对象。

        在java语言中，任何一个对象都有一把锁，其实这把锁就是标记，只是把它叫做锁。

        以下代码的执行原理？
        1。假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。
        2。假设t1先执行了，遇到了synchronized，这个时候自动找"后面共享对象"的对象锁，
            找到之后，占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是占有这把锁的。
            直到同步代码块代码结束，这把锁才会释放。
        3。假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面共享对象的这把锁，
            结果这把锁被t1占有，t2只能在同步代码块外等待t1的结束。t1执行同步代码块结束后，
            会归还这把锁。t2占有这把锁，进入同步代码块执行程序。
         */

        //思考2，下面的对象能作为共享对象放在synchronized()的括号里吗？
        Object obj2 = new Object();
        //不可以，因为obj2是局部变量，每一个线程都可以new一个，不是唯一的。

        //synchronized ("abc") { 
        // "abc"在常量池中只有一份，对于所有线程都是唯一的、可访问的，可以作为共享对象，但是这样所有的线程都会同步。
        //synchronized (null) { 空指针异常
        synchronized (this) {
            //线程同步代码块：

            //取款之前的余额
            double before = this.getBalance();
            //取款之后的余额
            double after = before - money;
            //假设网络有延迟1s
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //更新余额
            // t1执行到这里了，但没来得及执行这行代码，t2线程进来withdraw方法了，此时一定会出问题。
            this.setBalance(after);
        }
    }
}
```



总结：

synchronized 有三种写法：

第一种：同步代码块

第二种：在实例方法上使用，表示共享对象一定是this，并且同步代码块是整个方法体。

第三种：在静态方法上使用，表示找类锁。因为类只有一个，所以类锁只有一把，哪怕创建多个对象。



## 29）volatile

> adj. 易变的，动荡不定的，反复无常的；（计算机内存）易失的，非永久的。

Filed修饰符，不能修饰其他内容。

### 作用

#### 保证被修饰的变量，在线程中的可见性

Thread0 的run方法调用了m方法，CPU缓存中就拿了m方法和涉及到判断的flag的true值。

将flag设置为false的是main线程。

所以如果没有加volatile关键字，CPU缓存中 Thread0线程 flag的true值是永久性的，main线程改变flag值对Thread0已经加载的变量不会有影响。

如果加了volatile关键字，当main线程将flag值改变的时候，OS会通知CPU核心重新在主内存中读取flag值。

```java
package com.raywei.moreaboutjava.thread.volatiletest;

public class MyVolatileRunnable implements Runnable {
    private volatile boolean flag = true;

    @Override
    public void run() {
        m();
    }

    public void m() {
        System.out.println("method executes");
        while (flag) {

        }
        System.out.println("method exits");
    }

    public MyVolatileRunnable() {
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

```java
package com.raywei.moreaboutjava.thread.volatiletest;

public class VolatileTest {
    public static void main(String[] args) {
        MyVolatileRunnable m = new MyVolatileRunnable();

        new Thread(m).start();

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        m.setFlag(false);
    }
}
```



#### 防止CPU指令排序

在单例模式中使用。如果不使用关键字，可能线程会拿到一个尚未初始化完成的对象（内存，地址有了，但是里面没有东西）

```java
package com.raywei.moreaboutjava.thread.single02;

public class Single {
    //私有修饰构造方法
    private Single() {
    }

    //自己创建自己的对象 静态 懒汉式 又叫做对象的延迟加载
    //使用volatile关键字防止
    private static volatile Single single = null;

    //方法get，返回本类对象 静态
    public static Single getSingle() {
        //再次判断变量，提高效率
        if (single == null) {
            synchronized (Single.class) {
                //判断变量single，是空就创建
                if (single == null)
                    single = new Single();
        /**
         * 这里创建对象所需的几个步骤：
         * 1。开内存空间
         * 2。初始化成员变量
         * 3。调用构造方法
         * 4。地址赋值
         *
         * 排除第一个。如果说Thread0中CPU先执行了4，此时内存地址有了。
         * 但是CPU又去执行了Thread1，然后执行getSingle方法，
         * 判断single是否为空的时候，结果为false，因为single变量已经有内存地址了。
         * 所以return single，但是此时内存地址里什么也没有，会出现报错找不到类异常。
         */
            }
        }
        return single;
    }
}

```



## 30）ThreadLocal



## 31）Executors



## 32）JUC 强大的辅助类

### CountDownLatch 倒数计数器

```java
package com.raywei.juc;

import java.util.concurrent.CountDownLatch;

/**
 * @author Ray Wei
 * @Date 2022/4/16 13:29
 */
public class CountDownLatchDemo {

    public static void main(String[] args) {
        // 倒数计数器 将初始值设置为6
        CountDownLatch countDownLatch = new CountDownLatch(6);
        // 减一
        //countDownLatch.countDown();
        // 等待
        //countDownLatch.await();

        for (int i = 1; i < 7; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+ " CountDownLatch");
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }

        // 如果 倒数计数器的值不为0的话，那么应该等待
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 为0
        System.out.println(Thread.currentThread().getName()+ " 0000000 ====== CountDownLatch");

    }
}
```

### CyclicBarrier 循环栅栏

```java
package com.raywei.juc;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author Ray Wei
 * @Date 2022/4/16 21:09
 */
public class CyclicBarrierDemo {
    // 集齐7颗龙珠，召唤神龙
    public static void main(String[] args) {
        // CyclicBarrier(int parties, Runnable barrierAction)
        // CyclicBarrier(7, sout"召唤神龙")
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("集齐7颗龙珠，可召唤神龙！");
        });

        for (int i = 1; i < 8; i++) {
            // 创建线程
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 号龙珠已收");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }
    }
}
```

### Semaphore 信号量

```java
package com.raywei.juc;

import java.util.concurrent.Semaphore;

/**
 * @author Ray Wei
 * @Date 2022/4/16 21:31
 */
public class SemaphoreDemo {
    // 三个停车位，6辆汽车
    public static void main(String[] args) {
        // Semaphore(int permits, boolean fair) // 为true 则就是先进先出
        Semaphore semaphore = new Semaphore(3, true);
        // 模拟6辆汽车
        for (int i = 1; i < 7; i++) {
            new Thread(() -> {
                try {
                    // 获取资源
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "\t 抢到了车位");
                    Thread.sleep(1000);
                    System.out.println(Thread.currentThread().getName() + "\t -------离开");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放资源
                    semaphore.release();
                }

            }, String.valueOf(i)).start();
        }
    }
}
```



## 33）Thread

#### 线程生命周期

![](/Users/raywei/Desktop/LearnJava/note/img/线程生命周期.png)



#### 常用方法

### getName() & setName() & currentThread()

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest04 {
    public static void main(String[] args) {

        //currentThread就是当前线程对象
        //这个代码出现在main方法中，所以当前线程就主线程
        Thread currentThread = Thread.currentThread();
        System.out.println(currentThread.getName()); //main

        MyThread2 t0 = new MyThread2();
        //获取线程的名字
        System.out.println(t0.getName()); //Thread-0

        MyThread2 t1 = new MyThread2();
        System.out.println(t1.getName()); //Thread-1
        /*
        当没有设置线程的名字时，默认的名字有规律。
        Thread-0
        Thread-1
        Thread-2
        Thread-3
        ……
         */

        //设置线程的名字
        t0.setName("t0");
        t1.setName("t1");
        //System.out.println(t0.getName()); //t0

        t0.start();
        t1.start();
    }
}

class MyThread2 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            //当t1线程执行run方法，那么当前线程就是t1
            //当t2线程执行run方法，那么当前线程就是t2
            Thread currentThread = Thread.currentThread();
            System.out.println(currentThread.getName() + "-------" + i);
        }
    }
}
```



### sleep()

```java
package com.raywei.moreaboutjava.thread;
/*
static void    --> sleep(long millis) 参数是毫秒
让当前线程进入休眠，进入"阻塞状态"，放弃占有CPU时间片，让给其他线程使用。
*/
public class ThreadTest05 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
            try {
                Thread.sleep(1000); // 1s
                //这种方法可以做到间隔特定的时间，执行特定的代码，每隔多久执行一次
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest06 {
    public static void main(String[] args) {
        Thread t = new MyThread3();
        t.setName("t");
        t.start();

        try {
            //面试问题：这行代码会让线程t进入休眠状态吗？
            t.sleep(1000 * 5); //在执行的时候还是会转换成： Thread.sleep(1000 * 5);
                                    //这行代码的作用是让当前线程休眠，当前方法是main方法，所以是main方法休眠。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class MyThread3 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "---->" + i);
        }
    }
}
```

### 终止sleep()

```java
package com.raywei.moreaboutjava.thread;
/*
How to awake a thread in sleep?
 */
public class ThreadTest07 {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable2());
        t.setName("t");
        t.start();

        //假设：5s后，main方法需要t线程醒来
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //终止t线程的睡眠 这种方式依靠了Java的异常处理机制 try里抛异常，catch接住，然后结束
        //java.lang.InterruptedException: sleep interrupted
        t.interrupt();
    }
}

class MyRunnable2 implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "----> begin");
        // 父类Runnable里没有抛异常，子类重写的时候不能抛出更多/宽泛的异常
        // 所以run方法里不能throws，只能try catch
        try {

            Thread.sleep(1000 * 60 * 60 * 24);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "----> end");
    }
}
```

### 终止线程的执行

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest08 {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable3());
        t.setName("t");
        t.start();
        //模拟5s
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //5s之后强行终止t线程
        t.stop(); //已过时，强行终止，不建议使用
        //缺点：容易丢失数据，因为这种方式直接将线程杀死了，线程没有保存的数据将会丢失，不建议使用。
    }
}

class MyRunnable3 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest09 {
    public static void main(String[] args) {
        MyRunnable4 r = new MyRunnable4();
        Thread t = new Thread(r);
        t.setName("t");
        t.start();

        //模拟5s
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //终止线程
        r.run = false;
    }
}

class MyRunnable4 implements Runnable {
    //布尔标记
    boolean run = true;

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if (run) {
                System.out.println(Thread.currentThread().getName() + "--->" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else
                /*
                到了return就结束了，在结束前有什么没有保存的，可以在这里保存。
                 */
                //终止当前线程
                return;
        }

    }
}
```

#### join() 线程合并

void ---> join()	Waits for this thread to die.

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest12 {
    public static void main(String[] args) {
        System.out.println("main begin");

        Thread t = new Thread(new MyRunnable7());
        t.setName("t");
        t.start();

        //合并线程
        try {
            t.join(); //t合并到当前线程中，当前线程受阻塞，t线程执行直到结束。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("main end"); //最后输出
    }
}

class MyRunnable7 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```



#### yield() 线程让位

static void ---> yield() 让位方法，不是阻塞方法，让当前线程让位，让给其他线程使用。该方法的执行，会让当前线程中“运行状态”回到“就绪状态”。注意：在回到就绪之后，有可能还会再次抢到。

```java
package com.raywei.moreaboutjava.thread;

public class ThreadTest11 {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable6());
        t.setName("t");
        t.start();

        for (int i = 1; i <= 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}

class MyRunnable6 implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            //每100个让位一次
            if (i % 10 == 0)
                Thread.yield(); // 当前线程暂停一下，让给主线程
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```



## 34）Runnable

见33）



## 35）Callable

```
创建新类MyThread实现runnable接口
class MyThread implements Runnable{
 @Override
 public void run() {
 
 }
}
新类MyThread2实现callable接口
class MyThread2 implements Callable<Integer>{
 @Override
 public Integer call() throws Exception {
  return 200;
 } 
}
 面试题:callable接口与runnable接口的区别？
 答：
 （1）是否有返回值 callable 返回值是 object
 （2）是否抛异常 callable 抛异常
 （3）落地方法不一样，一个是run，一个是call
```

### FutureTask

java.util.concurrent.FutureTask\<V>，是 Runnable 接口的实现类。

因为 Thread 的构造方法没有Callable，所以需要找个中间人 FutureTask。 

在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。  

仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 即，只计算一次，get方法放到最后。

```java
package com.raywei.juc;

import java.util.concurrent.FutureTask;

/**
 * @author Ray Wei
 * @Date 2022/4/15 21:43
 */
public class CallableTest {
    public static void main(String[] args) {

        // 创建 FutureTask ，需要实现 Callable 函数式接口
        FutureTask<Integer> futureTask = new FutureTask<Integer>(() -> {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + " come in callable");
            // 设置返回值
            return 1;
        });

        // FutureTask 是 Runnable 的实现类
        new Thread(futureTask, "AA").start();

        // 可以在调用结果之前判断当前任务是否已经完成，如果没有完成，则等待
        while (!futureTask.isDone()) {
            System.out.println("waiting-----------");
        }
        try {
            Integer integer = futureTask.get();
            System.out.println("integer = " + integer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



## 36）Lock 接口

java.util.concurrent.locks包下

Lock接口替换了同步synchronized, 提供了更加灵活,性能更好的锁定操作

### ReentrantLock

public class ReentrantLock
extends Object
implements Lock, Serializable

使用方法

```java
class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...
 
   public void m() {
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 }
```

实例

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Ray Wei
 * @Date 2022/4/15 09:48
 */
public class TicketTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        // Thread(Runnable target, String name)
        new Thread(() -> {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 100; i++) {
                ticket.sale();
            } 
        },"AA").start();

        new Thread(() -> {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 100; i++) {
                ticket.sale();
            }
        },"BB").start();

        new Thread(() -> {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 100; i++) {
                ticket.sale();
            }
        },"CC").start();
    }
}

class Ticket {
    //定义票源
    private int tickets = 100;
    //获取Lock接口的实现类对象
    private final Lock lock = new ReentrantLock();

    public void sale() {
        //获取锁
        lock.lock();
        try {
            if (tickets > 0) {
                System.out.println(Thread.currentThread().getName() + "出售第" + tickets-- + "张" + "剩余" + tickets + "张");
            }
        } finally {
            //释放锁
            lock.unlock();
        }
    }
}
```



### Condition

在 java.util.concurrent.locks 包下，Lock接口中方法 :  newCondition() 方法的返回值是此接口。

- 线程的阻塞队列
  - 进入队列的线程,释放锁
  - 出去队列的线程,再次的获取锁
  - 接口的方法 : await() 线程释放锁,进入队列
  - 接口的方法 : signal() 线程出去队列,再次获取锁

> 使用await()和signal()方法，只是在JVM中完成唤醒和等待，不需要调用系统OS，性能更好，程序更快。

```java
package com.raywei.moreaboutjava.thread.lock.lock3;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Resource2 {
    private int count;
    private boolean flag; // false 表示消费完成，等待生产；true表示生产完成，等待消费。
    private Lock lock = new ReentrantLock();

    // 基于Lock接口锁，创建出2个线程的阻塞队列
    private Condition producer = lock.newCondition();
    private Condition customer = lock.newCondition();

    // 消费者调用
    public void getCount(  ) {
        // 获取锁
        lock.lock();
        // flag是false，消费完成，等待生产
        while (!flag) {
            // 消费线程无限等待，释放锁，进入生产线程队列中
            try {
                customer.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("消费第" + count + "个");
        // 消费完成
        flag = false;
        // 唤醒生产线程队列中的一个
        producer.signal();
        lock.unlock();
    }

    // 生产者调用
    public void setCount() {
        // 获取锁
        lock.lock();
        // flag为true时表明生产完成，等待消费
        while (flag) {
            // 生产者无限等待,释放锁，进入消费线程队列
            try {
                producer.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        count++;
        System.out.println("生产第" + count + "个");
        // 生产完成，更改标识
        flag = true;
        // 唤醒消费线程阻塞队列中的一个
        customer.signal();
        lock.unlock();
    }
}
```

#### Lock锁的实现原理

>  其使用的技术不开源，技术的名称叫做轻量级锁。



## 37）ReentrantReadWriteLock

java.util.concurrent.locks.ReentrantReadWriteLock

public class ReentrantReadWriteLock
extends Object
implements ReadWriteLock, Serializable

```java
package com.raywei.juc;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author Ray Wei
 * @Date 2022/4/17 09:50
 */
// 资源类: 用map模拟缓存读写数据
class MyCache {
    // volatile 关键字在多线程时最好加上！
    // private volatile HashMap<String, Object> map = new HashMap<>(); // 线程不安全
    private volatile Map<String, Object> map = new ConcurrentHashMap<>(); // 线程安全
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    // 写方法
    public void put(String key, Object value) {
        // 获得写锁
        readWriteLock.writeLock().lock();

        try {
            // 信息提示谁在写入数据
            System.out.println(Thread.currentThread().getName() + "\t 正在写" + key);
            Thread.sleep(300);
            map.put(key, value);
            // 信息提示写入完成
            System.out.println(Thread.currentThread().getName() + "\t 写入完成" + key);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 释放写锁
            readWriteLock.writeLock().unlock();
        }
    }

    // 写方法
    public Object get(String key) {
        // 获得读锁
        readWriteLock.readLock().lock();

        Object o = null;
        try {
            // 信息提示谁在写入数据
            System.out.println(Thread.currentThread().getName() + "\t 正在读" + key);
            Thread.sleep(300);

            o = map.get(key);
            // 信息提示写入完成
            System.out.println(Thread.currentThread().getName() + "\t 读完成" + key);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 释放读锁
            readWriteLock.readLock().unlock();
        }
        return o;
    }
}

public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        for (int i = 1; i < 6; i++) {
            int temp = i;
            new Thread(() -> {
                myCache.put(String.valueOf(temp), "temp" + temp);
            }, String.valueOf(i)).start();
        }

        for (int i = 1; i < 6; i++) {
            int temp = i;
            new Thread(() -> {
                myCache.get(String.valueOf(temp));
            }, String.valueOf(i)).start();
        }
    }
}
```



## 38）Atomic 相关类



## 参考链接：

[【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？](https://www.cnblogs.com/kismetv/p/10787228.html)

[乐观锁、悲观锁，这一篇就够了！](https://segmentfault.com/a/1190000016611415)



## 拓展链接：

[2.背景介绍](https://segmentfault.com/a/1190000014858404)

