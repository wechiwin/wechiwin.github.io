## 1）Java 内存结构

方法区method area和堆heap是线程共享的。

Java栈，本地方法栈，程序计数器是线程私有的。

<img src="https://s2.loli.net/2022/06/15/9tcmLKqCsuOIB8w.png" alt="jvm-002" style="zoom:80%;" />



## 2）堆 heap

- 一个程序（也就是一个main方法）对应着一个JVM实例，一个JVM实例只存在一个堆内存；
- java堆区在JVM启动的时候被创建，其空间大小也就确定了，是JVM管理的最大一块内存空间，但是堆内存是可以调节的
- 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）之后会有篇幅专门讲清楚TLAB是什么的。
- 《java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。但是从实际角度上看，应该是几乎所有对象的实例都在这里分配内存。
- 垃圾回收是在堆中进行的，栈是不涉及GC的
  

### JDK1.7 新生代+老年代+持久代

在jvm的堆内存中有三个区域：

1、年轻代：用于存放新产生的对象。Eden Space、Survivor 0 Space(from space)、Survivor 1 Space(to space)

2、老年代：用于存放被长期引用的对象。

3、持久代：用于存放Class，method元信息（1.8之后改为元空间）。

当数据经过GC从from区到to区后，下一次GC，有数据的又变成了from区，没数据的变成to区。

![jvm-008](https://s2.loli.net/2022/06/17/5Y9WyGPpKVzQv3Z.png)

### JDK1.8 新生代+老年代+元空间

JDK1.8之后，取消perm永久代，转而用元空间metaspace代替

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。并且可以动态扩容。那么使用元空间会有哪些问题呢？同学们可以思考下。

### 为什么分代？

因为不同对象的生命周期是不一样的。80%-98%的对象都是“朝生夕死”，生命周期很短，大部分新对象都在年轻代，可以很高效地进行回收，不用遍历所有对象。而老年代对象生命周期一般很长，每次可能只回收一小部分内存，回收效率很低。

年轻代和老年代的内存回收算法完全不同，因为年轻代存活的对象很少，标记清楚再压缩的效率很低，所以采用复制算法将存活对象移到survivor区，更高效。而老年代则相反，存活对象的变动很少，所以采用标记清楚压缩算法更合适。

#### 对象生死判定方法

##### 1、引用计数

每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

##### 2、可达性分析算法

![v9ifpjqyen](https://s2.loli.net/2022/06/21/Ifn5rFW67lXd8u9.png)

在主流商用语言(如Java、C#)的主流实现中, 都是通过可达性分析算法来判定对象是否存活的: 通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的, 如下图: Object5、6、7 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象:

在Java, 可作为GC Roots的对象包括:

方法区: 类静态属性引用的对象;

方法区: 常量引用的对象;

虚拟机栈(本地变量表)中引用的对象.

本地方法栈JNI(Native方法)中引用的对象。

注: 即使在可达性分析算法中不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记过程: 第一次是在可达性分析后发现没有与GC Roots相连接的引用链, 第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过). 



## 3）栈



## 4）垃圾回收器 Garbage Collector

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor/Young GC(YGC)和Major/Full GC(FGC)。

### YGC

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

### FGC

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

1.年老代（Tenured）被写满

2.持久代（Perm）被写满

3.System.gc()被显示调用

4.上一次GC之后Heap的各域分配策略动态变化

### GC 算法

栈：栈中的生命周期是跟随线程，所以一般不需要关注

<font color=pink>堆：堆中的对象是垃圾回收的重点</font>

方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点

#### 1、复制算法

YGC中使用的算法就是复制算法。

![image-20220621110037425](https://s2.loli.net/2022/06/21/mSW18UMHVLr9P2B.png)

Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden是就变成空的了。

当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。

-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数

HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

这种算法会将内存划分为两个相等的块，每次只使用其中一块。当这块内存不够使用时，就将还存活的对象复制到另一块内存中，然后把这块内存一次清理掉。这样做的效率比较高，也避免了内存碎片。但是这样内存的可使用空间减半，是个不小的损失。

优点

简单高效，不会出现内存碎片问题

缺点

内存利用率低，只有一半

存活对象较多时效率明显会降低

#### 2、标记-清除算法 Mark-Sweep

![image-20220413152701426](https://s2.loli.net/2022/06/21/8gGaCzfBnvkQD6K.png)

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 

标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象   标记为存活的对象。 

清除：遍历整个堆，把未标记的对象清除。 

用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 

Pros：

不需要额外空间

Cons：

两次扫描，耗时；可能会产生内存碎片。

1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲

2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 

#### 3、标记压缩

![image-20220413153910805](https://s2.loli.net/2022/06/21/A9a6Jr8lhRzPwvO.png)

在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。

可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 

标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 

标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。



#### 4、标记清除压缩 Mark-Sweep-Compact

标记清除和标记压缩的结合。

和标记清除一致，当进行多次GC后才压缩。

优点：进一步减少了移动对象的成本。



## 5）内存分配策略 TLAB(Thread Local Allocation Buffer)

![2352795668-508349c5b1cf8922](https://s2.loli.net/2022/06/21/7WoVn4q6KrlcANI.png)

#### 1、优先在Eden区分配

在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时, VM发起一次Minor GC, 将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域, 如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区, 则会通过空间分配担保机制使对象提前进入老年代(空间分配担保见下).

#### 2、大对象直接进入老年代

Serial和ParNew两款收集器提供了-XX:PretenureSizeThreshold的参数, 令大于该值的大对象直接在老年代分配, 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指 需要大量连续内存的Java对象, 如很长的字符串和数组), 因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间.

#### 3、长期存活对象进入老年区

 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中。

#### 4、对象年龄动态判定

如果在 Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

#### 5、空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

HotSpot默认是开启空间分配担保的。



## 6）JVM 参数调优

- 实际上每一块子内存区中都会存在有一部分的可变伸缩区 
- 如果空间不足时，则在可变范围之内扩大内存空间 
- 当一段时间后，内存空间有余，再将可变空间进行释放 

![b02fdfa0-41da-448c-85f7-44c685212852](https://s2.loli.net/2022/06/21/nmqGUEBuafhMQ5X.jpg)

堆的大小在JVM启动时就已经设定好了，可以通过"-Xmx"和"-Xms"来进行设置。

`-Xms`用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`。

`-Xmx`则用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`。一旦堆区中的内存大小超过`-Xmx`所指定的最大内存时，将会抛出OutOfMemoryError异常。

通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。当Xmx值比Xms值大时，堆可以动态收缩和扩展，避免了扩容机制的发生。

默认情况下，初始内存大小为：物理电脑内存大小/64 ，最大内存大小为：物理电脑内存大小/4

## 7）Java 内存模型 Java Memory Model



## 8）Java 对象模型 

- HotSpot
- 类加载机制
- 编译和反编译
- 反编译工具
- JIT
- 虚拟机性能监控和故障处理工具（jps、jstack、jmap、jstat、jconsole、javap）